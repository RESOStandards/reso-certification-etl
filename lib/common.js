const { standardMetadata } = require('./references/dd-1.7/standard-metadata');
const fs = require('fs/promises');

const CURRENT_DD_VERSION = '1.7';

/**
 * Gets metadata for a given version
 * This the metadata references come from:
 *
 *  https://raw.githubusercontent.com/RESOStandards/web-api-commander/main/src/main/resources/RESODataDictionary-1.7.metadata-report.json
 *
 * And is autogenerated with each version
 *
 * @param {String} version the version of the metadata to fetch, for example "1.7" (current default)
 * @returns the latest copy of the metadata file at the URL in the description
 */
const getMetadata = (version = CURRENT_DD_VERSION) =>
  require(`./references/dd-${version}/metadata-report.json`) || {};

const getLookupMap = (version = CURRENT_DD_VERSION) =>
  require(`./references/dd-${version}/lookup-map.js`) || {};

const getStandardMetadata = (version = CURRENT_DD_VERSION) =>
  require(`./references/dd-${version}/standard-metadata.js`) || {};

/**
 * Extracts the standard resources (in order) from the current reference metadata report file
 *
 * @param {String} version
 * @type function(string): string[]
 */
const getStandardResources = version => {
  const { resources = [] } = getMetadata(version);
  return resources?.map(resource => resource.resourceName);
};

const getFieldDetails = async (fieldName, resourceName) => {
  return standardMetadata.fields.find(
    field => field.fieldName === fieldName && field.resourceName === resourceName
  );
};

const getIdxLookups = (fields, lookups) => {
  const iDXDataTypes = [
    'String List, Multi',
    'String List,Multi',
    'String List, Single',
    'String List,Single'
  ];
  const iDXLookupFields = fields.filter(field =>
    standardMetadata.fields.some(
      x =>
        x.resourceName === field.resourceName &&
        x.fieldName === field.fieldName &&
        x.payloads.includes('IDX') &&
        iDXDataTypes.includes(x.simpleDataType?.trim())
    )
  );
  const uniqueIDXLookupFields = [...new Set(iDXLookupFields.map(field => field.type))];
  const standardLookups = standardMetadata.lookups;
  return lookups.filter(lookup => {
    return uniqueIDXLookupFields.some(
      field =>
        field === lookup.lookupName &&
        standardLookups.some(
          sLookup =>
            sLookup.lookupValue === lookup.lookupValue &&
            getLastPart(sLookup.lookupName, '.') === getLastPart(lookup.lookupName, '.')
        )
    );
  });
};

const getLastPart = (str, char) => str.substr(str.lastIndexOf(char) + 1);

const getAdvertisedCountPerResourcesByType = ({ fields, lookups }) => {
  const reducedFields = fields.reduce(function (r, a) {
    r[a.resourceName] = r[a.resourceName] || [];
    r[a.resourceName].push(a);
    return r;
  }, Object.create(null));
  const advertisedCount = {};
  const idxLookups = getIdxLookups(fields, lookups);
  for (const [key, value] of Object.entries(reducedFields)) {
    advertisedCount[key] = { fields: {}, lookups: {} };
    advertisedCount[key]['fields'] = { total: 0, reso: 0, idx: 0, local: 0 };
    advertisedCount[key]['lookups'] = { total: 0, reso: 0, idx: 0, local: 0 };
    const lookupsCollection = [];
    for (const field of value) {
      advertisedCount[key]['fields'].total++;
      if (field.standardRESO) {
        advertisedCount[key]['fields'].reso++;
        if (field?.payloads?.includes('IDX')) {
          advertisedCount[key]['fields'].idx++;
        }
      } else {
        advertisedCount[key]['fields'].local++;
      }
      //collect lookup on single pass
      if (!field?.type.startsWith('Edm.')) {
        lookupsCollection.push(...lookups.filter(lookup => lookup.lookupName === field.type));
      }
    }
    for (const lookup of lookupsCollection) {
      advertisedCount[key]['lookups'].total++;
      if (lookup.standardRESO) {
        advertisedCount[key]['lookups'].reso++;
        if (
          idxLookups.some(
            idxLookup =>
              idxLookup.lookupName === lookup.lookupName &&
              (idxLookup.lookupValue === lookup.lookupValue ||
                idxLookup?.annotations?.[0]?.value === lookup?.annotations?.[0]?.value)
          )
        ) {
          advertisedCount[key]['lookups'].idx++;
        }
      } else {
        advertisedCount[key]['lookups'].local++;
      }
    }
  }
  return advertisedCount;
};

const getIdxCounts = (fields, lookups) => {
  const idxFields = fields.filter(field =>
    standardMetadata.fields.some(
      x =>
        x.resourceName === field.resourceName &&
        x.fieldName === field.fieldName &&
        x.payloads.includes('IDX')
    )
  );
  const iDXFieldsCount = idxFields.length;

  // iDXResources
  const resources = [...new Set(fields.map(field => field.resourceName))];
  const iDXResourcesCount = resources.filter(resource =>
    standardMetadata.fields.some(x => x.resourceName === resource && x.payloads.includes('IDX'))
  ).length;

  /*  iDXLookups
  lookups of unique IDX fields with any of types ["String List, Single", String List, Multi] 
  */
  const iDXLookups = getIdxLookups(fields, lookups);
  const iDXLookupsCount = iDXLookups.length;
  return { iDXFieldsCount, iDXResourcesCount, iDXLookupsCount };
};

const getFieldsCount = fields => {
  const standardFieldsCount = fields.filter(field =>
    standardMetadata.fields.some(
      x => x.resourceName === field.resourceName && x.fieldName === field.fieldName
    )
  ).length;
  const localFieldsCount = fields.length - standardFieldsCount;
  return {
    standardFieldsCount,
    localFieldsCount,
    totalFieldsCount: fields.length
  };
};

const getResourcesCount = fields => {
  const resources = [...new Set(fields.map(field => field.resourceName))];
  const totalResourcesCount = resources.length;
  const standardResourcesCount = resources.filter(resource =>
    getStandardResources().some(x => x === resource)
  ).length;
  const localResourcesCount = totalResourcesCount - standardResourcesCount;
  return { standardResourcesCount, localResourcesCount, totalResourcesCount };
};

const getLookupsCount = lookups => {
  const standardLookupsCount = lookups.filter(lookup => lookup.standardRESO === true).length;
  const localLookupsCount = lookups.length - standardLookupsCount;
  return {
    standardLookupsCount,
    localLookupsCount,
    totalLookupsCount: lookups.length
  };
};

const writeFile = async (path, content = '') => {
  if (!path?.length) throw new Error('Path was empty in writeFile!');

  try {
    await fs.appendFile(path, Buffer.from(content));
  } catch (err) {
    console.log(err);
  }
};

const readFile = async (path = '') => {
  if (!path?.length) throw new Error('Path was empty in readFile!');

  try {
    return await fs.readFile(path, { encoding: 'utf8' });
  } catch (err) {
    console.log(err);
  }
};

module.exports = {
  getFieldDetails,
  getIdxCounts,
  getAdvertisedCountPerResourcesByType,
  getLookupsCount,
  getResourcesCount,
  getFieldsCount,
  writeFile,
  readFile,
  getMetadata,
  getLookupMap,
  getStandardMetadata
};
