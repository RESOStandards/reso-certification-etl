const fs = require('fs/promises');

const CURRENT_DD_VERSION = '1.7';
const STANDARD_NAME_ANNOTATION_TERM = 'RESO.OData.Metadata.StandardName';
const DD_WIKI_URL_TERM = 'RESO.DDWikiUrl';

const buildAnnotationMap = (annotations = []) =>
  annotations.reduce((acc, { term, value }) => {
    acc[term] = value;
    return acc;
  }, {});

/* eslint-disable */
const getSimpleDataType = (type, isCollection) => {
  switch (type) {
    case 'Edm.Bool':
      return 'Boolean';
    case 'Edm.Date':
      return 'Date';
    case 'Edm.Decimal':
    case 'Edm.Double':
    case 'Edm.Int64':
    case 'Edm.Int32':
    case 'Edm.Int16':
      return 'Number';
    case 'Edm.String':
      return isCollection ? 'String List, Multi' : 'String';
    case 'Edm.EnumType':
      return isCollection ? 'String List, Multi' : 'String List, Single';
    case 'Edm.DateTimeOffset':
      return 'Timestamp';
    default:
      return type;
  }
};

/**
 * Gets metadata for a given version
 * This the metadata references come from:
 *
 *  https://raw.githubusercontent.com/RESOStandards/web-api-commander/main/src/main/resources/RESODataDictionary-1.7.metadata-report.json
 *
 * And is autogenerated with each version
 *
 * @param {String} version the version of the metadata to fetch, for example "1.7" (current default)
 * @returns the latest copy of the metadata file at the URL in the description
 */
const getMetadata = (version = CURRENT_DD_VERSION) => require(`./references/dd-${version}/metadata-report.json`) || {};

/**
 *
 * @param {String} version
 * @returns The standard lookup map computed from the RESO metadata report for the version that is provided.
 */
const getLookupMap = (version = CURRENT_DD_VERSION) =>
  getMetadata(version)?.lookups?.reduce((acc, { lookupName, lookupValue, annotations }) => {
    const parsedLookupName = lookupName?.substring(lookupName?.lastIndexOf('.') + 1);
    const annotationMap = buildAnnotationMap(annotations);

    if (parsedLookupName && !acc[parsedLookupName]) acc[parsedLookupName] = [];
    acc[parsedLookupName].push({
      lookupValue,
      lookupDisplayName: annotationMap[STANDARD_NAME_ANNOTATION_TERM],
      wikiPageURL: annotationMap[DD_WIKI_URL_TERM]
    });
    return acc;
  }, {});

/**
 *
 * @param {String} version
 * @returns The standard metadata computed from the RESO metadata report for the version that is provided.
 */
const getStandardMetadata = (version = CURRENT_DD_VERSION) => {
  const { fields, lookups } = getMetadata(version) || {};
  const PAYLOADS_TERM = 'RESO.OData.Metadata.Payloads';
  const standardFields = fields?.map(field => {
    const annotationMap = buildAnnotationMap(field?.annotations);
    const url = annotationMap[DD_WIKI_URL_TERM];

    const type = field?.type?.startsWith('Edm.') ? field.type : 'Edm.EnumType';

    const payloads = (annotationMap[PAYLOADS_TERM] || '').split(',');

    const transformedField = {
      resourceName: field.resourceName,
      fieldName: field.fieldName,
      type: field.type,
      simpleDataType: getSimpleDataType(type, field.isCollection),
      payloads
    };

    if (url) {
      transformedField.wikiPageURL = url;
    }

    return transformedField;
  });

  const standardLookups = lookups?.map(lookup => {
    const annotationMap = buildAnnotationMap(lookup?.annotations);
    const url = annotationMap[DD_WIKI_URL_TERM];

    const transformedLookup = {
      lookupName: lookup.lookupName,
      lookupValue: lookup.lookupValue,
      type: lookup.type
    };

    if (url) {
      transformedLookup.wikiPageURL = url;
    }

    return transformedLookup;
  });

  return {
    description: 'RESO Data Dictionary Metadata Report',
    version,
    generatedOn: new Date().toISOString(),
    fields: standardFields,
    lookups: standardLookups
  };
};

/**
 * Extracts the standard resources (in order) from the current reference metadata report file
 *
 * @param {String} version
 * @type function(string): string[]
 */
const getStandardResources = version => {
  const metadata = getMetadata(version);
  const resources = [...new Set(metadata.fields.map(f => f.resourceName))];
  return resources;
};

const getFieldDetails = async (fieldName, resourceName) => {
  return getStandardMetadata().fields.find(field => field?.fieldName === fieldName && field?.resourceName === resourceName);
};

const getIdxLookups = (fields, lookups) => {
  const standardMetadata = getStandardMetadata();
  const iDXDataTypes = ['String List, Multi', 'String List,Multi', 'String List, Single', 'String List,Single'];
  const iDXLookupFields = fields.filter(field =>
    standardMetadata.fields.some(
      x =>
        x.resourceName === field.resourceName &&
        x.fieldName === field.fieldName &&
        x?.payloads?.includes('IDX') &&
        iDXDataTypes.includes(x.simpleDataType?.trim())
    )
  );
  const uniqueIDXLookupFields = [...new Set(iDXLookupFields.map(field => field.type))];
  const standardLookups = standardMetadata.lookups;
  return lookups.filter(lookup => {
    return uniqueIDXLookupFields.some(
      field =>
        field === lookup.lookupName &&
        standardLookups.some(
          sLookup =>
            sLookup.lookupValue === lookup.lookupValue && getLastPart(sLookup.lookupName, '.') === getLastPart(lookup.lookupName, '.')
        )
    );
  });
};

const getLastPart = (str, char) => str.substr(str.lastIndexOf(char) + 1);

const getAdvertisedCountPerResourcesByType = ({ fields, lookups }) => {
  const reducedFields = fields.reduce(function (r, a) {
    r[a.resourceName] = r[a.resourceName] || [];
    r[a.resourceName].push(a);
    return r;
  }, Object.create(null));
  const advertisedCount = {};
  const idxLookups = getIdxLookups(fields, lookups);
  for (const [key, value] of Object.entries(reducedFields)) {
    advertisedCount[key] = { fields: {}, lookups: {} };
    advertisedCount[key]['fields'] = { total: 0, reso: 0, idx: 0, local: 0 };
    advertisedCount[key]['lookups'] = { total: 0, reso: 0, idx: 0, local: 0 };
    const lookupsCollection = [];
    for (const field of value) {
      advertisedCount[key]['fields'].total++;
      if (field.standardRESO) {
        advertisedCount[key]['fields'].reso++;
        if (field?.payloads?.includes('IDX')) {
          advertisedCount[key]['fields'].idx++;
        }
      } else {
        advertisedCount[key]['fields'].local++;
      }
      //collect lookup on single pass
      if (!field?.type.startsWith('Edm.')) {
        lookupsCollection.push(...lookups.filter(lookup => lookup.lookupName === field.type));
      }
    }
    for (const lookup of lookupsCollection) {
      advertisedCount[key]['lookups'].total++;
      if (lookup.standardRESO) {
        advertisedCount[key]['lookups'].reso++;
        if (
          idxLookups.some(
            idxLookup =>
              idxLookup.lookupName === lookup.lookupName &&
              (idxLookup.lookupValue === lookup.lookupValue || idxLookup?.annotations?.[0]?.value === lookup?.annotations?.[0]?.value)
          )
        ) {
          advertisedCount[key]['lookups'].idx++;
        }
      } else {
        advertisedCount[key]['lookups'].local++;
      }
    }
  }
  return advertisedCount;
};

const getIdxCounts = (fields, lookups) => {
  const standardMetadata = getStandardMetadata();
  const idxFields = fields.filter(field =>
    standardMetadata.fields.some(
      x => x.resourceName === field.resourceName && x.fieldName === field.fieldName && x?.payloads?.includes('IDX')
    )
  );
  const iDXFieldsCount = idxFields.length;

  // iDXResources
  const resources = [...new Set(fields.map(field => field.resourceName))];
  const iDXResourcesCount = resources.filter(resource =>
    standardMetadata.fields.some(x => x.resourceName === resource && x?.payloads?.includes('IDX'))
  ).length;

  /*  iDXLookups
  lookups of unique IDX fields with any of types ["String List, Single", String List, Multi] 
  */
  const iDXLookups = getIdxLookups(fields, lookups);
  const iDXLookupsCount = iDXLookups.length;
  return { iDXFieldsCount, iDXResourcesCount, iDXLookupsCount };
};

const getFieldsCount = fields => {
  const standardMetadata = getStandardMetadata();
  const standardFieldsCount = fields.filter(field =>
    standardMetadata.fields.some(x => x.resourceName === field.resourceName && x.fieldName === field.fieldName)
  ).length;
  const localFieldsCount = fields.length - standardFieldsCount;
  return {
    standardFieldsCount,
    localFieldsCount,
    totalFieldsCount: fields.length
  };
};

const getResourcesCount = fields => {
  const resources = [...new Set(fields.map(field => field.resourceName))];
  const totalResourcesCount = resources.length;
  const standardResourcesCount = resources.filter(resource => getStandardResources().some(x => x === resource)).length;
  const localResourcesCount = totalResourcesCount - standardResourcesCount;
  return { standardResourcesCount, localResourcesCount, totalResourcesCount };
};

const getLookupsCount = lookups => {
  const standardLookupsCount = lookups.filter(lookup => lookup.standardRESO === true).length;
  const localLookupsCount = lookups.length - standardLookupsCount;
  return {
    standardLookupsCount,
    localLookupsCount,
    totalLookupsCount: lookups.length
  };
};

const writeFile = async (path, content = '') => {
  if (!path?.length) throw new Error('Path was empty in writeFile!');

  try {
    await fs.appendFile(path, Buffer.from(content));
  } catch (err) {
    console.log(err);
  }
};

const readFile = async (path = '') => {
  if (!path?.length) throw new Error('Path was empty in readFile!');

  try {
    return await fs.readFile(path, { encoding: 'utf8' });
  } catch (err) {
    console.log(err);
  }
};

const reportTypes = {
  DATA_DICTIONARY: {
    name: 'data_dictionary'
  },
  WEB_API_SERVER_CORE: {
    name: 'web_api_server_core'
  },
  DATA_DICTIONARY_WITH_IDX_PAYLOAD: {
    name: 'data_dictionary_with_IDX_payload'
  },
  DATA_AVAILABILITY: {
    name: 'data_availability'
  }
};

const CATEGORIES = Object.freeze({
  TOTAL: 'total',
  RESO: 'reso',
  LOCAL: 'local',
  IDX: 'idx'
});

module.exports = {
  getFieldDetails,
  getIdxCounts,
  getAdvertisedCountPerResourcesByType,
  getLookupsCount,
  getResourcesCount,
  getFieldsCount,
  writeFile,
  readFile,
  getMetadata,
  getLookupMap,
  getStandardMetadata,
  reportTypes,
  CATEGORIES
};
